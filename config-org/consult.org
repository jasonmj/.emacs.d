#+TITLE: Consult
#+PROPERTY: header-args      :tangle "../config-elisp/consult.el"
* Consult
#+BEGIN_SRC emacs-lisp
  ;; Example configuration for Consult
  (use-package consult
    :ensure t
    :bind (("C-c M-x" . consult-mode-command)
	   ("C-c h" . consult-history)
	   ("C-;" . consult-recent-file)
	   ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
	   ("s-SPC" . consult-buffer)                ;; orig. switch-to-buffer
	   ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
	   ("C-SPC" . consult-project-buffer)      ;; orig. project-switch-to-buffer
	   ("M-y" . consult-yank-pop)                ;; orig. yank-pop
	   ("M-g g" . consult-goto-line)             ;; orig. goto-line
	   ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
	   ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
	   ("M-g m" . consult-mark)
	   ("M-g k" . consult-global-mark)
	   ("M-g i" . consult-imenu)
	   ("M-g I" . consult-imenu-multi)
	   ;; M-s bindings (search-map)
	   ("M-s d" . consult-find)
	   ("M-s D" . consult-locate)
	   ("M-s g" . consult-grep)
	   ("M-s G" . consult-git-grep)
	   ("s-s" . consult-ripgrep)
	   ("M-s r" . consult-ripgrep)
	   ("M-s l" . consult-line)
	   ("M-s L" . consult-line-multi)
	   ("M-s k" . consult-keep-lines)
	   ("M-s u" . consult-focus-lines)
	   ;; Minibuffer history
	   :map minibuffer-local-map
	   ("M-s" . consult-history)                 ;; orig. next-matching-history-element
	   ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
	  register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
	  xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.

    :config
    ;; Consult-line
    (setq consult-line-start-from-top t)

    ;; Consult-yank-pop
    (defun my/consult-yank-pop (orig-fun &rest args)
      (interactive "p")
      (if (equal major-mode 'exwm-mode)
	  (let ((inhibit-read-only t))
	    (cl-letf (((symbol-function 'insert-for-yank)
		       (lambda (str) (kill-new str)
			 (exwm-input--fake-key ?\C-v))))
	      (apply orig-fun args)))
	(apply orig-fun args)))

    (advice-add 'consult-yank-pop :around #'my/consult-yank-pop)
  
    ;; Find File
    (key-seq-define-global "xf" 'find-file)
    (global-set-key (kbd "C-x f") 'find-file)
    (global-set-key (kbd "M-SPC") 'project-find-file)

    ;; Switch buffer
    (exwm-input-set-key (kbd "C-SPC") (lambda ()
					(interactive)
					(if (project-current)
					    (consult-project-buffer)
					  (consult-buffer))))
    (key-seq-define-global "cz" 'execute-extended-command)

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    (setq consult-preview-key 'any)
    (consult-customize consult-recent-file :preview-key 'nil
		       consult-theme :preview-key '(:debounce 0.5 any)
		       consult-project-buffer :preview-key 'nil
		       consult-buffer :preview-key 'nil)

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; "C-+"

    ;; Buffer filtering
    (setq consult-buffer-filter '("^ " "\\` " "\\*Echo Area" "\\*Minibuf" "\\*Quail Completions"
				  "\\*elixir-ls" "Flymake log" "Shell command output" "direnv" "\\*scratch"
				  "\\*Messages" "\\*Warning" "*magit-" "magit-process" "*vterm" "vterm" "^:" "*Occur"
				  "*straight-" "*elfeed-log" "*trace of SMTP session" "\\*Compile-Log" "\\*blamer"
				  "*format-all-error" "*Async-" "COMMIT_EDITMSG" "shell: " "\\*ednc-log"
				  "*lsp-" "*EGLOT" "*pyls")))
#+END_SRC
* Consult at Point
#+BEGIN_SRC emacs-lisp
(defun consult-line-at-point ()
  "Custom function to pick up a thing at a point for consult-line

If a selected region exists, it will be searched for by consult-linee
If there is a symbol at the current point, its textual representation is
searched. If there is no symbol, empty search box is started."
  (interactive)
  (consult-line (selection-or-thing-at-point)))
(key-seq-define-global "vf" 'consult-line-at-point)
(key-seq-define-global "vd" 'consult-line-at-point)

(defun consult-ripgrep-at-point ()
  (interactive)
  (consult-ripgrep nil (selection-or-thing-at-point)))
(exwm-input-set-key (kbd "S-SPC") 'consult-ripgrep-at-point)

(defun selection-or-thing-at-point ()
  (cond
   ;; If there is selection use it
   ((and transient-mark-mode
         mark-active
         (not (eq (mark) (point))))
    (let ((mark-saved (mark))
          (point-saved (point)))
      (deactivate-mark)
      (buffer-substring-no-properties mark-saved point-saved)))
   ;; Otherwise, use symbol at point or empty
   (t (format "%s"
              (or (thing-at-point 'symbol)
                  "")))))
#+END_SRC
* Consult Web Search
#+begin_src emacs-lisp
  (require 'request)

  (cl-defun consult-web--handle-error (&rest args &key error-thrown &allow-other-keys)
    "Handle error from `request' with ARGS.

  Display a message with the ERROR-THROWN."
    (error "Web search error: %S" error-thrown))

  (defun consult-web--request (url parser &optional placeholder)
    "Search using the given URL and PARSER.

  PLACEHOLDER is returned for immediate display by `completing-read'.  The
  actual list of candidates is later updated by the \:success
  function."
    (let (candidates)
      (request
	url
	:sync t
	:headers '(("User-Agent" . "Emacs"))
	:parser parser
	:error #'consult-web--handle-error
	:success (cl-function (lambda (&key data &allow-other-keys)
				(setq candidates data))))
      candidates))

  (defun consult-web--format-candidate (text url)
    "Format TEXT and URL as an `completing-read' candidate."
    (let ((url (url-unhex-string url)))
      (propertize (concat text "\n" (propertize url 'face 'shadow)) 'shr-url url)))

  (defun consult-web-search--duckduckgo (string)
    "Retrieve search results from DuckDuckGo for STRING."
    (consult-web--request
     (concat "https://duckduckgo.com/html/?q=" (url-hexify-string string))
     (lambda ()
       (mapcar
	(lambda (a)
	  (let* ((href (assoc-default 'href (dom-attributes a))))
	    (consult-web--format-candidate
	     (dom-texts a)
	     ;; DDG sometimes appends "&rut...", which I can only guess is an
	     ;; anti-bot measure. See https://github.com/mnewt/counsel-web/issues/3.
	     (substring href (string-match "http" href) (string-match "&rut=" href)))))
	(dom-by-class (libxml-parse-html-region (point-min) (point-max)) "result__a")))
     "Searching DuckDuckGo..."))

  (defun consult-web-search ()
    "Search the web with Consult."
    (interactive)
    (let* ((string (read-string "Web Search: " nil nil))
	   (results (consult-web-search--duckduckgo string))
	   (selection (completing-read "Results: " results)))
      (browse-url (car (cdr (split-string selection "\n"))))))

  (defun consult-web-thing-at-point ()
    "Interactively search the web for the THING at point."
    (interactive)
    (counsel-web-search (selection-or-thing-at-point)))
#+end_src
